#!/bin/bash
set -euo pipefail

print_usage() {
  cat <<EOF
Usage: $(basename "$0") PATTERN -f FILE [-b BYTES] [-m MATCH]

  PATTERN            Regex pattern to search for (required, first positional argument)
  -f, --file FILE    File to search (required)
  -b, --bytes N      Number of bytes to extract (default: 1000)
  -m, --match N      Match number to use (1-based index, default: 1)
  -h, --help         Show this help message
EOF
  exit 1
}

# defaults
BYTES=1000
MATCH_INDEX=1

# first positional is the pattern
if [[ "${1:-}" =~ ^- ]]; then
  echo "Error: Missing PATTERN as first argument."
  print_usage
fi
PATTERN=$1; shift

# parse flags
while (( $# )); do
  case $1 in
    -f|--file)     FILE=$2; shift 2;;
    --file=*)      FILE=${1#*=}; shift;;
    -b|--bytes)    BYTES=$2; shift 2;;
    --bytes=*)     BYTES=${1#*=}; shift;;
    -m|--match)    MATCH_INDEX=$2; shift 2;;
    --match=*)     MATCH_INDEX=${1#*=}; shift;;
    -h|--help)     print_usage;;
    *) echo "Unknown option: $1"; print_usage;;
  esac
done

# validate
: "${PATTERN:?PATTERN not set}"
: "${FILE:?--file is required}"
[[ -f $FILE ]] || { echo "Error: File '$FILE' not found."; exit 1; }

# gather matches into an array (one “offset:match” per element)
MATCHES=()
i=0
while IFS= read -r line; do
  MATCHES[i++]="$line"
done < <(rg -b -o "$PATTERN" "$FILE")

NUM_MATCHES=${#MATCHES[@]}
if (( NUM_MATCHES == 0 )); then
  echo "No matches found for '$PATTERN'."
  exit 1
elif (( MATCH_INDEX < 1 || MATCH_INDEX > NUM_MATCHES )); then
  echo "Error: Match index $MATCH_INDEX out of range (1–$NUM_MATCHES)."
  exit 1
fi

echo "Using match #$MATCH_INDEX of $NUM_MATCHES"

# extract byte offset and snip
MATCH_LINE=${MATCHES[MATCH_INDEX-1]}
OFFSET=${MATCH_LINE%%:*}

dd if="$FILE" bs=1 skip="$OFFSET" count="$BYTES" status=none
